/**
 * Schema Alignment Tests - Verify Python encoder matches TypeScript decoder
 *
 * This test reads test cases generated by Python (tests/generate_schema_test_cases.py)
 * and verifies that the TypeScript decoder produces the expected output.
 *
 * Run with: npx tsx tests/schema-alignment.test.ts
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

import {
  decodeWrappedStoryV3,
  type WrappedStoryV3,
  type TopProjectV3,
  type TimelineEvent,
  type SessionFingerprint,
  type TraitScores,
  type TokenStats,
  type YearOverYear,
} from '../src/decoder';

// Get directory path
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Test utilities
let passed = 0;
let failed = 0;
const errors: string[] = [];

function assertEqual<T>(actual: T, expected: T, path: string): boolean {
  const actualStr = JSON.stringify(actual);
  const expectedStr = JSON.stringify(expected);
  if (actualStr === expectedStr) {
    return true;
  }
  errors.push(`  ${path}:\n    Expected: ${expectedStr}\n    Actual: ${actualStr}`);
  return false;
}

function assertDeepEqual(actual: any, expected: any, path: string = ''): boolean {
  // Handle null/undefined
  if (actual === expected) return true;
  if (actual === null || expected === null) {
    return assertEqual(actual, expected, path);
  }
  if (actual === undefined || expected === undefined) {
    return assertEqual(actual, expected, path);
  }

  // Handle arrays
  if (Array.isArray(expected)) {
    if (!Array.isArray(actual)) {
      errors.push(`  ${path}: Expected array, got ${typeof actual}`);
      return false;
    }
    if (actual.length !== expected.length) {
      errors.push(`  ${path}: Array length mismatch: expected ${expected.length}, got ${actual.length}`);
      return false;
    }
    let allMatch = true;
    for (let i = 0; i < expected.length; i++) {
      if (!assertDeepEqual(actual[i], expected[i], `${path}[${i}]`)) {
        allMatch = false;
      }
    }
    return allMatch;
  }

  // Handle objects
  if (typeof expected === 'object') {
    if (typeof actual !== 'object' || Array.isArray(actual)) {
      errors.push(`  ${path}: Expected object, got ${Array.isArray(actual) ? 'array' : typeof actual}`);
      return false;
    }

    const expectedKeys = Object.keys(expected).sort();
    const actualKeys = Object.keys(actual).sort();

    // Check for missing keys in actual
    let allMatch = true;
    for (const key of expectedKeys) {
      const newPath = path ? `${path}.${key}` : key;
      if (!(key in actual)) {
        errors.push(`  ${newPath}: Missing key`);
        allMatch = false;
      } else if (!assertDeepEqual(actual[key], expected[key], newPath)) {
        allMatch = false;
      }
    }

    // Check for extra keys in actual (that shouldn't be there)
    for (const key of actualKeys) {
      if (!(key in expected)) {
        // Some keys may be optional and set to undefined/null
        if (actual[key] !== undefined && actual[key] !== null) {
          const newPath = path ? `${path}.${key}` : key;
          errors.push(`  ${newPath}: Unexpected extra key with value ${JSON.stringify(actual[key])}`);
          allMatch = false;
        }
      }
    }

    return allMatch;
  }

  // Handle primitives
  return assertEqual(actual, expected, path);
}

interface TestCase {
  id: string;
  description: string;
  encoded: string;
  expected: any;
}

function runTests() {
  console.log('\n=== Schema Alignment Tests ===\n');
  console.log('Verifying Python encoder output matches TypeScript decoder expectations\n');

  // Load test cases
  const testCasesPath = path.join(__dirname, '../../tests/fixtures/schema_test_cases.json');

  if (!fs.existsSync(testCasesPath)) {
    console.error(`Test cases file not found: ${testCasesPath}`);
    console.error('Run "python tests/generate_schema_test_cases.py" first');
    process.exit(1);
  }

  const testCases: TestCase[] = JSON.parse(fs.readFileSync(testCasesPath, 'utf-8'));
  console.log(`Loaded ${testCases.length} test cases\n`);

  for (const tc of testCases) {
    errors.length = 0;  // Clear errors for each test

    console.log(`Test: ${tc.id}`);
    console.log(`  ${tc.description}`);

    try {
      const decoded = decodeWrappedStoryV3(tc.encoded);
      const matches = assertDeepEqual(decoded, tc.expected);

      if (matches) {
        console.log(`  ✓ Passed\n`);
        passed++;
      } else {
        console.log(`  ✗ Failed:`);
        for (const err of errors) {
          console.log(err);
        }
        console.log('');
        failed++;
      }
    } catch (e) {
      console.log(`  ✗ Exception: ${e}`);
      console.log('');
      failed++;
    }
  }

  // Summary
  console.log('=== Summary ===');
  console.log(`Passed: ${passed}`);
  console.log(`Failed: ${failed}`);
  console.log('');

  if (failed > 0) {
    console.log('SCHEMA MISMATCH DETECTED!');
    console.log('Python encoder and TypeScript decoder are not aligned.');
    console.log('Fix the discrepancy before deploying.');
    process.exit(1);
  } else {
    console.log('All schema alignment tests passed!');
    console.log('Python encoder and TypeScript decoder are aligned.');
  }
}

runTests();
